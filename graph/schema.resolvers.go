package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.38

import (
	"context"
	"fmt"
	"os"
	"time"

	"github.com/golang-jwt/jwt"
	"github.com/tonrock01/go_fiber_gql/db"
	"github.com/tonrock01/go_fiber_gql/graph/model"
	"golang.org/x/crypto/bcrypt"
)

// Signup is the resolver for the signup field.
func (r *mutationResolver) Signup(ctx context.Context, input model.SignUp) (string, error) {
	req := model.SignUp{
		Username:  input.Username,
		Password:  input.Password,
		Firstname: input.Firstname,
		Lastname:  input.Lastname,
	}

	if req.Username == "" || req.Password == "" || req.Firstname == "" || req.Lastname == "" {
		return "Invalid SignUp", fmt.Errorf("invalid signup")
	}

	checkUser := model.User{}
	db.Db.Where("username = ?", req.Username).First(&checkUser)
	// if st, _ := strconv.Atoi(checkUser.ID); st > 0 {
	// 	return "This username already used", fmt.Errorf("this username already used")
	// }
	if checkUser.ID > 0 {
		return "This username already used", fmt.Errorf("this username already used")
	}

	hashpassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
	if err != nil {
		return "Can not hash password", fmt.Errorf("can not hash password")
	}

	user := model.User{
		Username:  req.Username,
		Password:  string(hashpassword),
		Firstname: req.Firstname,
		Lastname:  req.Lastname,
	}

	db.Db.Create(&user)
	if user.ID > 0 {
		return "SignUp Success", fmt.Errorf("signup success")
	} else {
		return "SignUp Failed", fmt.Errorf("signup failed")
	}
}

// Signin is the resolver for the signin field.
func (r *mutationResolver) Signin(ctx context.Context, input model.SignIn) (string, error) {
	req := model.SignIn{
		Username: input.Username,
		Password: input.Password,
	}

	if req.Username == "" || req.Password == "" {
		return "Some field is empty", fmt.Errorf("some field is empty")
	}

	checkUser := model.User{}
	db.Db.Where("username = ?", req.Username).First(&checkUser)
	if checkUser.ID == 0 {
		return "User dose not exist", fmt.Errorf("user dose not exist")
	}

	err := bcrypt.CompareHashAndPassword([]byte(checkUser.Password), []byte(req.Password))
	if err == nil {
		token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
			"username": checkUser.Username,
			"exp":      time.Now().Add(time.Minute * 1).Unix(),
		})
		t, err := token.SignedString([]byte(os.Getenv("SECRET_KEY")))
		if err != nil {
			return "Internal server error", fmt.Errorf("internal server error")
		}
		return "Login Success " + "Token : " + t, nil
	} else {
		return "Incorrect password", fmt.Errorf("incorrect password")
	}
}

// Currentuser is the resolver for the currentuser field.
func (r *queryResolver) Currentuser(ctx context.Context) (string, error) {
	// secretKey := []byte(os.Getenv("SECRET_KEY"))
	// var tokenString string
	// if authorization, ok := ctx.Value("Authorization").(string); ok {
	// 	if strings.HasPrefix(authorization, "Bearer ") {
	// 		tokenString = strings.TrimPrefix(authorization, "Bearer ")
	// 	} else {
	// 		return "Can not find token", fmt.Errorf("can not find token")
	// 	}
	// }

	// if tokenString == "" {
	// 	return "empty token", fmt.Errorf("empty token")
	// }

	// token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
	// 	if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
	// 		return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
	// 	}

	// 	return secretKey, nil
	// })

	// if err != nil {
	// 	return "Invalidate token", fmt.Errorf("invalidate token")
	// }

	// if claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {
	// 	user := model.User{}
	// 	db.Db.Where("username = ?", claims["username"]).First(&user)

	// 	responseUser := model.ResponseUser{
	// 		Username:  user.Username,
	// 		Firstname: user.Firstname,
	// 		Lastname:  user.Lastname,
	// 	}

	// 	return "status : Success" + string(responseUser.Firstname), nil
	// } else {
	return "Failed", fmt.Errorf("no info")
	// }
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
